)
?case_when
# Check the data
head(house_values)
## All zip codes are missing leading 0s (where applicable)
house_values1 <- house_values %>% case_when((zipcode / 10000) < 1 ~ paste0(0,zipcode))
## All zip codes are missing leading 0s (where applicable)
house_values1 <- house_values %>% case_when(((zipcode / 10000) < 1) ~ paste0(0, zipcode))
sapply(house_values$zipcode, function(x){if(nchar(x)<5){paste0(x,0)}else{x}})
house_values$zipcode
house_values$zipcode
show(house_values$zipcode)
head(house_values$zipcode, 20)
head(house_values$zipcode, 50)
head(house_values$zipcode, 80)
house_values$zipcode <- sapply(house_values$zipcode, function(x){if(nchar(x)<5){paste0(x,0)}else{x}})
head(house_values$zipcode, 80)
head(house_values$zipcode, 90)
head(house_values$zipcode, 100)
head(house_values$zipcode, 600)
head(house_values$zipcode, 900)
head(house_values$zipcode, 1000)
# Read the data
house_values = read.csv('./data/home_values.csv', header=TRUE, sep = ',')
# Check the data
head(house_values)
# Clean the data
## Rename columns
house_values <- house_values %>%
rename(rank = SizeRank,
zipcode = RegionName,
county = CountyName,
city = City,
state = State
)
head(house_values$zipcode, 1000)
house_values$zipcode <- sapply(house_values$zipcode, function(x){if(nchar(x)<5){paste0(0,x)}else{x}})
head(house_values$zipcode, 1000)
library(tidyverse) # contains ggplot2, dplyr, tidyr, readr, purr, tibble, stringr, forcats
library(MASS)
library(lubridate)
house_values = read.csv('./data/home_values.csv', header=TRUE, sep = ',')
house_forecasts = read.csv('./data/home_forecasts.csv', header=TRUE, sep = ',')
rentals = read.csv('./data/rentals.csv', header=TRUE, sep = ',')
head(house_values)
head(house_forecasts)
head(rentals)
house_values <- house_values %>%
rename(rank = SizeRank,
zipcode = RegionName,
county = CountyName,
city = City,
state = State
)
house_forecasts <- house_forecasts %>%
rename(zipcode = RegionName,
state = StateName,
county = CountyName,
city = CityName,
date = ForecastedDate,
appreciation = ForecastYoYPctChange
)
rentals <- rentals %>%
rename(rank = SizeRank,
zipcode = RegionName,
city_state = MsaName,
)
house_values$zipcode <- sapply(house_values$zipcode, function(x){if(nchar(x)<5){paste0(0,x)}else{x}})
house_forecasts$zipcode <- sapply(house_forecasts$zipcode, function(x){if(nchar(x)<5){paste0(0,x)}else{x}})
rentals$zipcode <- sapply(rentals$zipcode, function(x){if(nchar(x)<5){paste0(0,x)}else{x}})
house_values <- pivot_longer(house_values, cols=10:315, names_to = "date", values_to = "price")
rentals <- pivot_longer(rentals, cols=5:94, names_to = "date", values_to = "price")
house_values$date <- sub(".", "", house_values$date) # remove the leading "X"
house_values$date <- as_date(house_values$date)
house_forecasts$date <- as_date(house_forecasts$date)
rentals$date <- sub(".", "", rentals$date) # remove the leading "X"
rentals$date <- parse_date_time(rentals$date, "ym") # convert to date_time so day value is added
rentals$date <- as_date(rentals$date) # covert to date to drop time value
rentals$date <- rentals$date-1 # subtract 1 day so values align with other datasets
house_values_trim <- house_values %>% filter(date > "2013-12-01")
house_all <- house_values_trim %>% full_join(rentals, by = c('zipcode', 'date'), copy = FALSE, suffix = c(".x", ".y"))
head(house_all)
house_all <- house_all %>%
rename(ID = RegionID.x,
rank = rank.x,
price = price.x,
rent = price.y)
house_all <- house_all %>% select_('ID', 'rank', 'zipcode', 'state', 'city', 'Metro', 'county', 'date', 'price', 'rent')
house_all <- house_all %>% drop_na(price, rent, zipcode, date)
str(house_all)
summary(house_all)
house_all %>% group_by(zipcode) %>%
summarize(mean_price=mean(price),
sd_price=sd(price),
mean_rent=mean(rent),
sd_rent=sd(rent)
)
boxplot(house_all$rent)
boxplot(house_all$price)
boxplot(price ~ state, data = house_all)
boxplot(price ~ state, data = (house_all %>% filter(state=='NY' | state=='NJ' | state=='CT' | state=='PA')))
cor(house_all$price, house_all$rent)
hist(house_all$price, xlab = 'Price (USD)', main = 'Property Price Distribution')
hist(house_all$rent, xlab = 'Rent (USD)', main = 'Rent Cost Distribution')
ggplot(data = house_all, mapping = aes(x = price, y = rent)) + theme_bw() +
geom_point() + ggtitle("Rent vs. Price") + xlab('Price (USD)') + ylab('Rent (USD)') + stat_smooth(method = lm, se=FALSE)
model = lm(rent ~ price, data=house_all)
summary(model)
plot(model)
bc <- boxcox(rent ~ price, data=house_all)
lambda <- bc$x[which.max(bc$y)]
lambda
model_bc <- lm(((rent^(lambda)-1)/lambda) ~ price, data = house_all)
summary(model_bc)
plot(model_bc)
op <- par(pty = "s", mfrow = c(1,2))
qqnorm(model$residuals)
qqline(model$residuals)
qqnorm(model_bc$residuals)
qqline(model_bc$residuals)
par(op)
shiny::runApp()
library(dplyr)
library(lubridate)
allzips <- readRDS("data/superzip.rds")
Homes_all <- read_csv("./data/Homes_all.csv")
Homes_2022 <- read_csv("./data/Homes_2022.csv")
allzips$latitude <- jitter(allzips$latitude)
allzips$longitude <- jitter(allzips$longitude)
allzips$zipcode <- formatC(allzips$zipcode, width=5, format="d", flag="0")
row.names(allzips) <- allzips$zipcode
allzips <- inner_join(allzips, Homes_2022, by = c('zipcode'), copy = FALSE)
allzips <- allzips %>% mutate(none = 1+ price*0)
cleantable <- allzips %>%
select(
City = city,
State = state,
Zipcode = zipcode,
Year = year,
Rent = rent,
Price = price,
Appreciation = appreciation,
Profit_Ratio = revenue,
None = none,
Lat = latitude,
Long = longitude
)
house_all %>% filter(rent > 7000)
# All rent over $7000 is from one zipcode!
house_all %>% filter(price > 3500000)
# All price over 3500000 is from two zipcodes!
house_trim <- house_all %>% filter(zipcode != 90265 & zipcode != 94301)
hist(house_trim$price, xlab = 'Price (USD)', main = 'Property Price Distribution')
hist(house_trim$rent, xlab = 'Rent (USD)', main = 'Rent Cost Distribution')
bc <- boxcox(rent ~ price, data=house_trim)
lambda_trim <- bc$x[which.max(bc$y)]
lambda_trim
model_trim <- lm(((rent^(lambda_trim)-1)/lambda_trim) ~ price, data = house_trim)
summary(model_trim)
plot(model_trim)
Homes <- house_trim %>% select_('rank', 'zipcode', 'state', 'city', 'county', 'date', 'price', 'rent')
Homes <- Homes %>% group_by(zipcode) %>% arrange(date, .by_group = TRUE) %>%
mutate(appreciation = ((price - lag(price))/lag(price))*100)
Homes <- Homes %>% drop_na(appreciation)
Homes <- Homes %>% mutate(profit = (((appreciation/100)*price)+rent)/price)
Homes
Homes_yearly = Homes %>% mutate(year = format(date, "%Y")) %>%
group_by(zipcode, year) %>%
summarise(price_year = mean(price),
rent_year = mean(rent),
rev_year = sum(profit),
apprec_year = sum(appreciation)
)
Homes_yearly
home_forecasts <- house_forecasts %>% filter(Region == 'Zip')
home_forecasts <- home_forecasts %>% select_('zipcode', 'state', 'county', 'city', 'date', 'appreciation')
home_forecasts <- home_forecasts %>% mutate(year = format(date, "%Y"), apprec_year = appreciation)
home_forecasts <- home_forecasts %>% select_('zipcode', 'state', 'county', 'city', 'year', 'apprec_year')
home_forecasts
Homes_all <- left_join(Homes_yearly, home_forecasts, by = c('zipcode'), copy = FALSE)
Homes_all <- Homes_all %>% select_('zipcode',
year = 'year.x', 'price_year', 'rent_year',
'rev_year', apprec_year = 'apprec_year.x',
'state', 'county', 'city'
)
Homes_all <- full_join(Homes_all, home_forecasts,
by = c('zipcode', 'year', 'apprec_year', 'state', 'county', 'city'),
copy = FALSE
)
# Remove rows where zip code only shows up once
Homes_all <- Homes_all %>% group_by(zipcode) %>% arrange(year, .by_group = TRUE)
Homes_all <- Homes_all %>% group_by(zipcode) %>% filter(n() != 1)
# Calculate price from previous year and 2022 forecasted appreciation
Homes_all <- Homes_all %>% mutate(price_yr = case_when(year == 2022 ~ (lag(price_year)+((apprec_year/100)*lag(price_year))),
year != 2022 ~ price_year))
# Originally used previous linear regression to calculate predicted rent for 2022 but values looked too far off
# Assume rent for 2022 did not change from previous year (conservative estimate of revenue)
Homes_all <- Homes_all %>% mutate(rent_yr = case_when(year == 2022 ~ 12*lag(rent_year),
year != 2022 ~ 12*rent_year))
# Recalculate rev_yr = (appreciation($) + rent) / price
Homes_all <- Homes_all %>% mutate(rev_yr = ((apprec_year/100)*price_yr+rent_yr)/price_yr)
# Remove old columns that have been mutated
Homes_all <- Homes_all %>% select_('zipcode', 'year', 'state',
'county', 'city', appreciation = 'apprec_year',
price = 'price_yr', rent = 'rent_yr', revenue = 'rev_yr') %>% group_by(zipcode)
Homes_all <- Homes_all %>% arrange(desc(revenue), .by_group = TRUE)
Homes_all
Homes_2022 <- Homes_all %>% filter(year == 2022) %>% arrange(desc(revenue))
Homes_2022
ggplot(data = Homes_2022, aes(x = state, y = revenue)) + geom_boxplot()
ggplot(data = Homes_2022, aes(x = appreciation, y = revenue)) + geom_point()
ggplot(data = Homes_2022, aes(x = price, y = rent)) + geom_point()
ggplot(data = Homes_all %>% filter(zipcode == '63136'), aes(x = year, y = revenue)) + geom_point()
library(dplyr)
library(lubridate)
allzips <- readRDS("data/superzip.rds")
Homes_all <- read_csv("./data/Homes_all.csv")
Homes_2022 <- read_csv("./data/Homes_2022.csv")
allzips$latitude <- jitter(allzips$latitude)
allzips$longitude <- jitter(allzips$longitude)
allzips$zipcode <- formatC(allzips$zipcode, width=5, format="d", flag="0")
row.names(allzips) <- allzips$zipcode
allzips <- inner_join(allzips, Homes_2022, by = c('zipcode'), copy = FALSE)
allzips <- allzips %>% mutate(none = 1+ price*0)
cleantable <- allzips %>%
select(
City = city,
State = state,
Zipcode = zipcode,
Year = year,
Rent = rent,
Price = price,
Appreciation = appreciation,
Profit_Ratio = revenue,
None = none,
Lat = latitude,
Long = longitude
)
library(leaflet)
library(RColorBrewer)
library(scales)
library(lattice)
library(dplyr)
library(lubridate)
# Leaflet bindings are a bit slow; for now we'll just sample to compensate
set.seed(100)
zipdata <- allzips[sample.int(nrow(allzips), 1657),]
# By ordering by centile, we ensure that the (comparatively rare) SuperZIPs
# will be drawn last and thus be easier to see
zipdata <- zipdata[order(zipdata$revenue),]
function(input, output, session) {
## Interactive Map ###########################################
# Create the map
output$map <- renderLeaflet({
leaflet() %>%
addTiles() %>%
setView(lng = -93.85, lat = 37.45, zoom = 4)
})
# A reactive expression that returns the set of zips that are
# in bounds right now
zipsInBounds <- reactive({
if (is.null(input$map_bounds))
return(zipdata[FALSE,])
bounds <- input$map_bounds
latRng <- range(bounds$north, bounds$south)
lngRng <- range(bounds$east, bounds$west)
subset(zipdata,
latitude >= latRng[1] & latitude <= latRng[2] &
longitude >= lngRng[1] & longitude <= lngRng[2])
})
# Precalculate the breaks we'll need for the two histograms
revenueBreaks <- hist(plot = FALSE, allzips$revenue, breaks = 20)$breaks
output$histRevenue <- renderPlot({
# If no zipcodes are in view, don't plot
if (nrow(zipsInBounds()) == 0)
return(NULL)
hist(zipsInBounds()$revenue,
breaks = revenueBreaks,
main = "Profit Score (visible zipcodes)",
xlab = "Profit Score",
xlim = range(allzips$revenue),
col = '#00DD00',
border = 'white')
})
output$scatterAppreciationYear <- renderPlot({
# If no zipcodes are in view, don't plot
if (nrow(zipsInBounds()) == 0)
return(NULL)
print(xyplot(rent ~ price, data = zipsInBounds(), xlab = 'Price (USD)', ylab = 'Rent (USD)',
xlim = range(allzips$price), ylim = range(allzips$rent)))
})
# This observer is responsible for maintaining the circles and legend,
# according to the variables the user has chosen to map to color and size.
observe({
colorBy <- input$color
sizeBy <- input$size
if (colorBy == "price") {
colorData <- zipdata[[colorBy]]
pal <- colorBin("viridis", colorData, 7, pretty = FALSE)
} else {
colorData <- zipdata[[colorBy]]
pal <- colorBin("viridis", colorData, 7, pretty = FALSE)
}
if (sizeBy == "price") {
radius <- zipdata[[sizeBy]] / max(zipdata[[sizeBy]]) * 30000
} else {
radius <- zipdata[[sizeBy]] / max(zipdata[[sizeBy]]) * 30000
}
leafletProxy("map", data = zipdata) %>%
clearShapes() %>%
addCircles(~longitude, ~latitude, radius=radius, layerId=~zipcode,
stroke=FALSE, fillOpacity=0.4, fillColor=pal(colorData)) %>%
addLegend("bottomleft", pal=pal, values=colorData, title=colorBy,
layerId="colorLegend")
})
# Show a popup at the given location
showZipcodePopup <- function(zipcode, lat, lng) {
selectedZip <- allzips[allzips$zipcode == zipcode,]
content <- as.character(tagList(
tags$h4("Profit Ratio:", as.numeric(selectedZip$revenue)),
tags$strong(HTML(sprintf("%s, %s %s",
selectedZip$city, selectedZip$state, selectedZip$zipcode
))), tags$br(),
sprintf("Household price: %s", dollar(selectedZip$price)), tags$br(),
sprintf("Yr/yr appreciation: %s%%", as.numeric(selectedZip$appreciation)), tags$br(),
sprintf("Household rent: %s", dollar(selectedZip$rent)), tags
))
leafletProxy("map") %>% addPopups(lng, lat, content, layerId = zipcode)
}
# When map is clicked, show a popup with city info
observe({
leafletProxy("map") %>% clearPopups()
event <- input$map_shape_click
if (is.null(event))
return()
isolate({
showZipcodePopup(event$id, event$lat, event$lng)
})
})
## Data Explorer ###########################################
observe({
cities <- if (is.null(input$states)) character(0) else {
filter(cleantable, State %in% input$states) %>%
`$`('City') %>%
unique() %>%
sort()
}
stillSelected <- isolate(input$cities[input$cities %in% cities])
updateSelectizeInput(session, "cities", choices = cities,
selected = stillSelected, server = TRUE)
})
observe({
zipcodes <- if (is.null(input$states)) character(0) else {
cleantable %>%
filter(State %in% input$states,
is.null(input$cities) | City %in% input$cities) %>%
`$`('Zipcode') %>%
unique() %>%
sort()
}
stillSelected <- isolate(input$zipcodes[input$zipcodes %in% zipcodes])
updateSelectizeInput(session, "zipcodes", choices = zipcodes,
selected = stillSelected, server = TRUE)
})
observe({
if (is.null(input$goto))
return()
isolate({
map <- leafletProxy("map")
map %>% clearPopups()
dist <- 0.5
zip <- input$goto$zip
lat <- input$goto$lat
lng <- input$goto$lng
showZipcodePopup(zip, lat, lng)
map %>% fitBounds(lng - dist, lat - dist, lng + dist, lat + dist)
})
})
output$ziptable <- DT::renderDataTable({
df <- cleantable %>%
filter(
Price >= input$minPrice,
Price <= input$maxPrice,
is.null(input$states) | State %in% input$states,
is.null(input$cities) | City %in% input$cities,
is.null(input$zipcodes) | Zipcode %in% input$zipcodes
) %>%
mutate(Action = paste('<a class="go-map" href="" data-lat="', Lat, '" data-long="', Long, '" data-zip="', Zipcode, '"><i class="fa fa-crosshairs"></i></a>', sep=""))
action <- DT::dataTableAjax(session, df, outputId = "ziptable")
DT::datatable(df, options = list(ajax = list(url = action)), escape = FALSE)
})
}
library(leaflet)
# Choices for drop-downs
vars <- c(
"Profit Score" = "revenue",
"Property value" = "price",
"Property rent" = "rent",
"Property Appreciation" = "appreciation",
"None" = "none"
)
navbarPage("Property Investment App", id="nav",
tabPanel("Interactive map",
div(class="outer",
tags$head(
# Include custom CSS
includeCSS("styles.css"),
includeScript("gomap.js")
),
# If not using custom CSS, set height of leafletOutput to a number instead of percent
leafletOutput("map", width="100%", height="100%"),
# Shiny versions prior to 0.11 should use class = "modal" instead.
absolutePanel(id = "controls", class = "panel panel-default", fixed = TRUE,
draggable = TRUE, top = 60, left = "auto", right = 20, bottom = "auto",
width = 400, height = "auto",
h2("Real Estate Explorer"),
selectInput("color", "Color", vars),
selectInput("size", "Size", vars),
plotOutput("histRevenue", height = 250),
plotOutput("scatterAppreciationYear", height = 350)
),
tags$div(id="cite",
'Data compiled for ', tags$em('Coming Apart: The State of White America, 1960–2010'), ' by Charles Murray (Crown Forum, 2012).'
)
)
),
tabPanel("Data explorer",
fluidRow(
column(3,
selectInput("states", "States", c("All states"="", structure(state.abb, names=state.name), "Washington, DC"="DC"), multiple=TRUE)
),
column(3,
conditionalPanel("input.states",
selectInput("cities", "Cities", c("All cities"=""), multiple=TRUE)
)
),
column(3,
conditionalPanel("input.states",
selectInput("zipcodes", "Zipcodes", c("All zipcodes"=""), multiple=TRUE)
)
)
),
fluidRow(
column(2,
numericInput("minPrice", "Min price", min=0, max=5000000, value=1)
),
column(2,
numericInput("maxPrice", "Max price", min=0, max=5000000, value=5000000)
)
),
hr(),
DT::dataTableOutput("ziptable")
),
conditionalPanel("false", icon("crosshair"))
)
runApp()
library(dplyr)
library(lubridate)
allzips <- readRDS("data/superzip.rds")
Homes_all <- read_csv("./data/Homes_all.csv")
Homes_2022 <- read_csv("./data/Homes_2022.csv")
allzips$latitude <- jitter(allzips$latitude)
allzips$longitude <- jitter(allzips$longitude)
allzips$zipcode <- formatC(allzips$zipcode, width=5, format="d", flag="0")
row.names(allzips) <- allzips$zipcode
allzips <- inner_join(allzips, Homes_2022, by = c('zipcode'), copy = FALSE)
allzips <- allzips %>% mutate(none = 1+ price*0)
cleantable <- allzips %>%
select(
City = city,
State = state,
Zipcode = zipcode,
Year = year,
Rent = rent,
Price = price,
Appreciation = appreciation,
Profit_Ratio = revenue,
None = none,
Lat = latitude,
Long = longitude
)
detach("package:MASS", unload = TRUE)
library(dplyr)
library(lubridate)
allzips <- readRDS("data/superzip.rds")
Homes_all <- read_csv("./data/Homes_all.csv")
Homes_2022 <- read_csv("./data/Homes_2022.csv")
allzips$latitude <- jitter(allzips$latitude)
allzips$longitude <- jitter(allzips$longitude)
allzips$zipcode <- formatC(allzips$zipcode, width=5, format="d", flag="0")
row.names(allzips) <- allzips$zipcode
allzips <- inner_join(allzips, Homes_2022, by = c('zipcode'), copy = FALSE)
allzips <- allzips %>% mutate(none = 1+ price*0)
# Make sure MASS package is unloaded for the select function
cleantable <- allzips %>%
select(
City = city,
State = state,
Zipcode = zipcode,
Year = year,
Rent = rent,
Price = price,
Appreciation = appreciation,
Profit_Ratio = revenue,
None = none,
Lat = latitude,
Long = longitude
)
runApp()
library(MASS)
detach("package:MASS", unload = TRUE)
runApp()
