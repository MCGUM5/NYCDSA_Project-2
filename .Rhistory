}
return(prod)
}
Fac2(10)
Fac2(10)
Fac2 = function(i){
prod = 1
x=1
while(x <= i){
prod = prod*x
x = x+1
}
return(prod)
}
Fac2(10)
Fac2(10)
FAc2(10)
Fac2(10)
Fac2 = function(i){
prod = 1
x=1
while(x <= i){
prod = prod*x
x = x+1
}
return(prod)
}
Fac2 = function(i){
prod = 1
x=1
while(x <= i){
prod = prod*x
x = x+1
}
return(prod)
}
Fac2(10)
View(Fac2)
Fac2(10)
A = P*(1+(r/100))^n
P = 5000
P = 5000
r = 11.5
n = [1:15]
A = P*(1+(r/100))^n
P = 5000
r = 11.5
n = c[1:15]
n = c(1:15)
P = 5000
r = 11.5
n = c(1:15)
A = P*(1+(r/100))^n
Print(A)
print(A)
height = c(180, 165, 160, 193)
mass = c(87, 58, 65, 100)
tall = height > 182.88
BMI = mass / ((height*.01)^2)
print(tall)
print(BMI)
print(BMI)
print(tall)
data(cars)
print(!data(cars))
data1 = data(cars)
head(data1)
head(data1, 5)
data(cars)
head(data("cars"), 5)
head(data("cars"), 5)
print(head(data("cars"), 5))
print(head(data("cars")))
data("cars")
data1 = data("cars")
print(head(data1))
force(cars)
print(head(cars))
print(head(cars, 5))
print(head(cars))
print(head(cars,5))
cars
print(head(cars,5))
state = sample(c('NY', 'CA', 'CT'), size = 50, replace = TRUE)
set.seed(0)
state = sample(c('NY', 'CA', 'CT'), size = 50, replace = TRUE)
cars$state = state
cars$ratio = cars$dist / cars$speed
mean(cars$ratio)
sd(cars$ratio)
print(head(cars,5))
set.seed(0)
state = sample(c('NY', 'CA', 'CT'), size = 50, replace = TRUE)
cars$state = state
cars$ratio = cars$dist / cars$speed
mean(cars$ratio)
sd(cars$ratio)
ts_data = read.csv('https://s3.amazonaws.com/graderdata/TimesSquareSignage.csv', stringsAsFactors=FALSE)
summary(ts_data)
UpperBway = (ts_data$Location = 'Midtown Manhattan'
UpperBway = (ts_data$Location = 'Midtown Manhattan')
UpperBway = (ts_data$Location == 'Midtown Manhattan')
UpperBway
head(ts_data)
ts_data
UpperBway = subset(ts_data, Location == 'Upper Bway')
UpperBway
write.csv(UpperBway, file = 'UpperBway.csv', row.names=F)
ts_data
mean(ts_data$SF)
SF = subset(ts_data, SF > mean(ts_Data$SF))
SF = subset(ts_data, SF > mean(ts_data$SF))
write.csv(SF, file = 'SF.csv', row.names=F)
ts_sortSF = filter(ts_data, row_number(desc(SF)))
row_number = rank(ties.method = 'first')
row_number = rank(ties.method = SF)
ts_sortSF = order(ts_data$SF)
ts_sortSF
TopTen = ts_data[ts_sortSF, ]
TopTen
ts_sortSF = order(ts_data$SF, descending = TRUE)
ts_sortSF = order(ts_data$SF,decreasing = TRUE)
ts_sortSF
TopTen = ts_data[ts_sortSF, ]
TopTen
TS_Sorted = ts_data[ts_sortSF, ]
TopTen = TS_Sorted[0:10, ]
TopTen
TopTen1 = TS_Sorted[0:10, ]
TopTen = subset(TopTen1, select = 'name', 'address', 'location')
TopTen1 = TS_Sorted[0:10, ]
TopTen1
TopTen = subset(TopTen1, select = c(1, 2, 4))
TopTen
write.csv(TopTen, file = 'TopTen.csv', row.names=F)
P = 5000
r = 11.5
n = c(1:15)
A = P*(1+(r/100))^n
print(A)
height = c(180, 165, 160, 193)
mass = c(87, 58, 65, 100)
tall = height > 182.88
BMI = mass / ((height*.01)^2)
print(BMI)
print(tall)
print(head(cars,5))
set.seed(0)
state = sample(c('NY', 'CA', 'CT'), size = 50, replace = TRUE)
cars$state = state
cars$ratio = cars$dist / cars$speed
mean(cars$ratio)
sd(cars$ratio)
UpperBway = subset(ts_data, Location == 'Upper Bway')
write.csv(UpperBway, file = 'UpperBway.csv', row.names=F)
mean(ts_data$SF)
SF = subset(ts_data, SF > mean(ts_data$SF))
write.csv(SF, file = 'SF.csv', row.names=F)
ts_sortSF = order(ts_data$SF,decreasing = TRUE)
ts_sortSF
TS_Sorted = ts_data[ts_sortSF, ]
TopTen1 = TS_Sorted[0:10, ]
TopTen = subset(TopTen1, select = c(1, 2, 4))
write.csv(TopTen, file = 'TopTen.csv', row.names=F)
UpperBway = subset(ts_data, Location == 'Upper Bway')
write.csv(UpperBway, file = 'UpperBway.csv', row.names=F)
mean(ts_data$SF)
SF = subset(ts_data, SF > mean(ts_data$SF))
write.csv(SF, file = 'SF.csv', row.names=F)
ts_sortSF = order(ts_data$SF,decreasing = TRUE)
TS_Sorted = ts_data[ts_sortSF, ]
TopTen1 = TS_Sorted[0:10, ]
TopTen = subset(TopTen1, select = c(1, 2, 4))
write.csv(TopTen, file = 'TopTen.csv', row.names=F)
UpperBway = subset(ts_data, Location == 'Upper Bway')
write.csv(UpperBway, file = 'UpperBway.csv', row.names=F)
SF = subset(ts_data, SF > mean(ts_data$SF))
write.csv(SF, file = 'SF.csv', row.names=F)
ts_sortSF = order(ts_data$SF,decreasing = TRUE)
TS_Sorted = ts_data[ts_sortSF, ]
TopTen1 = TS_Sorted[0:10, ]
TopTen = subset(TopTen1, select = c(1, 2, 4))
write.csv(TopTen, file = 'TopTen.csv', row.names=F)
print(x)
i=2
x=c(1,1)
while (x[i] < 4000000) {
x[i+1] = x[i-1] + x[i]
i = i+1
}
x = x[-1]
print(x)
i=2
x=c(1,1)
while (x[i] < 4000000) {
x[i+1] = x[i-1] + x[i]
i = i+1
}
print(x)
sum(x[1:33])
library(tidyverse) # contains ggplot2, dplyr, tidyr, readr, purr, tibble, stringr, forcats
library(lubridate) # for manipulating dates
setwd("~/Desktop/NYCDSA/Projects/Project_2")
library(tidyverse) # contains ggplot2, dplyr, tidyr, readr, purr, tibble, stringr, forcats
library(lubridate) # for manipulating dates
house_values <- house_values %>%
rename(rank = SizeRank,
zipcode = RegionName,
county = CountyName,
city = City,
state = State
)
# Read the data
house_values = read.csv('./data/home_values.csv', header=TRUE, sep = ',')
library(dplyr)
allzips <- readRDS("data/superzip.rds")
allzips$latitude <- jitter(allzips$latitude)
allzips$longitude <- jitter(allzips$longitude)
allzips$college <- allzips$college * 100
allzips$zipcode <- formatC(allzips$zipcode, width=5, format="d", flag="0")
row.names(allzips) <- allzips$zipcode
cleantable <- allzips %>%
select(
City = city.x,
State = state.x,
Zipcode = zipcode,
Rank = rank,
Score = centile,
Superzip = superzip,
Population = adultpop,
College = college,
Income = income,
Lat = latitude,
Long = longitude
)
library(leaflet)
library(RColorBrewer)
library(scales)
library(lattice)
library(dplyr)
# Leaflet bindings are a bit slow; for now we'll just sample to compensate
set.seed(100)
zipdata <- allzips[sample.int(nrow(allzips), 10000),]
# By ordering by centile, we ensure that the (comparatively rare) SuperZIPs
# will be drawn last and thus be easier to see
zipdata <- zipdata[order(zipdata$centile),]
function(input, output, session) {
## Interactive Map ###########################################
# Create the map
output$map <- renderLeaflet({
leaflet() %>%
addTiles() %>%
setView(lng = -93.85, lat = 37.45, zoom = 4)
})
# A reactive expression that returns the set of zips that are
# in bounds right now
zipsInBounds <- reactive({
if (is.null(input$map_bounds))
return(zipdata[FALSE,])
bounds <- input$map_bounds
latRng <- range(bounds$north, bounds$south)
lngRng <- range(bounds$east, bounds$west)
subset(zipdata,
latitude >= latRng[1] & latitude <= latRng[2] &
longitude >= lngRng[1] & longitude <= lngRng[2])
})
# Precalculate the breaks we'll need for the two histograms
centileBreaks <- hist(plot = FALSE, allzips$centile, breaks = 20)$breaks
output$histCentile <- renderPlot({
# If no zipcodes are in view, don't plot
if (nrow(zipsInBounds()) == 0)
return(NULL)
hist(zipsInBounds()$centile,
breaks = centileBreaks,
main = "SuperZIP score (visible zips)",
xlab = "Percentile",
xlim = range(allzips$centile),
col = '#00DD00',
border = 'white')
})
output$scatterCollegeIncome <- renderPlot({
# If no zipcodes are in view, don't plot
if (nrow(zipsInBounds()) == 0)
return(NULL)
print(xyplot(income ~ college, data = zipsInBounds(), xlim = range(allzips$college), ylim = range(allzips$income)))
})
# This observer is responsible for maintaining the circles and legend,
# according to the variables the user has chosen to map to color and size.
observe({
colorBy <- input$color
sizeBy <- input$size
if (colorBy == "superzip") {
# Color and palette are treated specially in the "superzip" case, because
# the values are categorical instead of continuous.
colorData <- ifelse(zipdata$centile >= (100 - input$threshold), "yes", "no")
pal <- colorFactor("viridis", colorData)
} else {
colorData <- zipdata[[colorBy]]
pal <- colorBin("viridis", colorData, 7, pretty = FALSE)
}
if (sizeBy == "superzip") {
# Radius is treated specially in the "superzip" case.
radius <- ifelse(zipdata$centile >= (100 - input$threshold), 30000, 3000)
} else {
radius <- zipdata[[sizeBy]] / max(zipdata[[sizeBy]]) * 30000
}
leafletProxy("map", data = zipdata) %>%
clearShapes() %>%
addCircles(~longitude, ~latitude, radius=radius, layerId=~zipcode,
stroke=FALSE, fillOpacity=0.4, fillColor=pal(colorData)) %>%
addLegend("bottomleft", pal=pal, values=colorData, title=colorBy,
layerId="colorLegend")
})
# Show a popup at the given location
showZipcodePopup <- function(zipcode, lat, lng) {
selectedZip <- allzips[allzips$zipcode == zipcode,]
content <- as.character(tagList(
tags$h4("Score:", as.integer(selectedZip$centile)),
tags$strong(HTML(sprintf("%s, %s %s",
selectedZip$city.x, selectedZip$state.x, selectedZip$zipcode
))), tags$br(),
sprintf("Median household income: %s", dollar(selectedZip$income * 1000)), tags$br(),
sprintf("Percent of adults with BA: %s%%", as.integer(selectedZip$college)), tags$br(),
sprintf("Adult population: %s", selectedZip$adultpop)
))
leafletProxy("map") %>% addPopups(lng, lat, content, layerId = zipcode)
}
# When map is clicked, show a popup with city info
observe({
leafletProxy("map") %>% clearPopups()
event <- input$map_shape_click
if (is.null(event))
return()
isolate({
showZipcodePopup(event$id, event$lat, event$lng)
})
})
## Data Explorer ###########################################
observe({
cities <- if (is.null(input$states)) character(0) else {
filter(cleantable, State %in% input$states) %>%
`$`('City') %>%
unique() %>%
sort()
}
stillSelected <- isolate(input$cities[input$cities %in% cities])
updateSelectizeInput(session, "cities", choices = cities,
selected = stillSelected, server = TRUE)
})
observe({
zipcodes <- if (is.null(input$states)) character(0) else {
cleantable %>%
filter(State %in% input$states,
is.null(input$cities) | City %in% input$cities) %>%
`$`('Zipcode') %>%
unique() %>%
sort()
}
stillSelected <- isolate(input$zipcodes[input$zipcodes %in% zipcodes])
updateSelectizeInput(session, "zipcodes", choices = zipcodes,
selected = stillSelected, server = TRUE)
})
observe({
if (is.null(input$goto))
return()
isolate({
map <- leafletProxy("map")
map %>% clearPopups()
dist <- 0.5
zip <- input$goto$zip
lat <- input$goto$lat
lng <- input$goto$lng
showZipcodePopup(zip, lat, lng)
map %>% fitBounds(lng - dist, lat - dist, lng + dist, lat + dist)
})
})
output$ziptable <- DT::renderDataTable({
df <- cleantable %>%
filter(
Score >= input$minScore,
Score <= input$maxScore,
is.null(input$states) | State %in% input$states,
is.null(input$cities) | City %in% input$cities,
is.null(input$zipcodes) | Zipcode %in% input$zipcodes
) %>%
mutate(Action = paste('<a class="go-map" href="" data-lat="', Lat, '" data-long="', Long, '" data-zip="', Zipcode, '"><i class="fa fa-crosshairs"></i></a>', sep=""))
action <- DT::dataTableAjax(session, df, outputId = "ziptable")
DT::datatable(df, options = list(ajax = list(url = action)), escape = FALSE)
})
}
library(leaflet)
# Choices for drop-downs
vars <- c(
"Is SuperZIP?" = "superzip",
"Centile score" = "centile",
"College education" = "college",
"Median income" = "income",
"Population" = "adultpop"
)
navbarPage("Superzip", id="nav",
tabPanel("Interactive map",
div(class="outer",
tags$head(
# Include our custom CSS
includeCSS("styles.css"),
includeScript("gomap.js")
),
# If not using custom CSS, set height of leafletOutput to a number instead of percent
leafletOutput("map", width="100%", height="100%"),
# Shiny versions prior to 0.11 should use class = "modal" instead.
absolutePanel(id = "controls", class = "panel panel-default", fixed = TRUE,
draggable = TRUE, top = 60, left = "auto", right = 20, bottom = "auto",
width = 330, height = "auto",
h2("ZIP explorer"),
selectInput("color", "Color", vars),
selectInput("size", "Size", vars, selected = "adultpop"),
conditionalPanel("input.color == 'superzip' || input.size == 'superzip'",
# Only prompt for threshold when coloring or sizing by superzip
numericInput("threshold", "SuperZIP threshold (top n percentile)", 5)
),
plotOutput("histCentile", height = 200),
plotOutput("scatterCollegeIncome", height = 250)
),
tags$div(id="cite",
'Data compiled for ', tags$em('Coming Apart: The State of White America, 1960–2010'), ' by Charles Murray (Crown Forum, 2012).'
)
)
),
tabPanel("Data explorer",
fluidRow(
column(3,
selectInput("states", "States", c("All states"="", structure(state.abb, names=state.name), "Washington, DC"="DC"), multiple=TRUE)
),
column(3,
conditionalPanel("input.states",
selectInput("cities", "Cities", c("All cities"=""), multiple=TRUE)
)
),
column(3,
conditionalPanel("input.states",
selectInput("zipcodes", "Zipcodes", c("All zipcodes"=""), multiple=TRUE)
)
)
),
fluidRow(
column(1,
numericInput("minScore", "Min score", min=0, max=100, value=0)
),
column(1,
numericInput("maxScore", "Max score", min=0, max=100, value=100)
)
),
hr(),
DT::dataTableOutput("ziptable")
),
conditionalPanel("false", icon("crosshair"))
)
shiny::runApp()
house_forecasts = read.csv('./data/home_forecasts.csv', header=TRUE, sep = ',')
setwd("~/Desktop/NYCDSA/Projects/Project_2")
house_forecasts = read.csv('./data/home_forecasts.csv', header=TRUE, sep = ',')
rentals = read.csv('./data/rentals.csv', header=TRUE, sep = ',')
library(tidyverse) # contains ggplot2, dplyr, tidyr, readr, purr, tibble, stringr, forcats
library(lubridate) # for manipulating dates
# Read the data
house_values = read.csv('./data/home_values.csv', header=TRUE, sep = ',')
house_forecasts = read.csv('./data/home_forecasts.csv', header=TRUE, sep = ',')
rentals = read.csv('./data/rentals.csv', header=TRUE, sep = ',')
house_values <- house_values %>%
rename(rank = SizeRank,
zipcode = RegionName,
county = CountyName,
city = City,
state = State
)
?case_when
# Check the data
head(house_values)
## All zip codes are missing leading 0s (where applicable)
house_values1 <- house_values %>% case_when((zipcode / 10000) < 1 ~ paste0(0,zipcode))
## All zip codes are missing leading 0s (where applicable)
house_values1 <- house_values %>% case_when(((zipcode / 10000) < 1) ~ paste0(0, zipcode))
sapply(house_values$zipcode, function(x){if(nchar(x)<5){paste0(x,0)}else{x}})
house_values$zipcode
house_values$zipcode
show(house_values$zipcode)
head(house_values$zipcode, 20)
head(house_values$zipcode, 50)
head(house_values$zipcode, 80)
house_values$zipcode <- sapply(house_values$zipcode, function(x){if(nchar(x)<5){paste0(x,0)}else{x}})
head(house_values$zipcode, 80)
head(house_values$zipcode, 90)
head(house_values$zipcode, 100)
head(house_values$zipcode, 600)
head(house_values$zipcode, 900)
head(house_values$zipcode, 1000)
# Read the data
house_values = read.csv('./data/home_values.csv', header=TRUE, sep = ',')
# Check the data
head(house_values)
# Clean the data
## Rename columns
house_values <- house_values %>%
rename(rank = SizeRank,
zipcode = RegionName,
county = CountyName,
city = City,
state = State
)
head(house_values$zipcode, 1000)
house_values$zipcode <- sapply(house_values$zipcode, function(x){if(nchar(x)<5){paste0(0,x)}else{x}})
head(house_values$zipcode, 1000)
